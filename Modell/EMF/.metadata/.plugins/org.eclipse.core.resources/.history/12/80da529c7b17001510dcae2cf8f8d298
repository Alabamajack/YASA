/**
 */
package shootingmachineemfmodel.tests;

import java.io.*;

import java.nio.file.Files;
import java.nio.file.Paths;

import org.eclipse.emf.common.util.Diagnostic;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.util.Diagnostician;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;

import shootingmachineemfmodel.ShootingmachineemfmodelFactory;
import shootingmachineemfmodel.ShootingmachineemfmodelPackage;
import shootingmachineemfmodel.ToplevelSystem;
import shootingmachineemfmodel.util.ShootingmachineemfmodelResourceFactoryImpl;

/**
 * <!-- begin-user-doc -->
 * A sample utility for the '<em><b>shootingmachineemfmodel</b></em>' package.
 * <!-- end-user-doc -->
 * @generated
 */
public class ShootingmachineemfmodelExample {
	/**
	 * <!-- begin-user-doc -->
	 * Load all the argument file paths or URIs as instances of the model.
	 * <!-- end-user-doc -->
	 * @param args the file paths or URIs.
	 * @generated
	 */
	public static void main(String[] args) {
		// Create a resource set to hold the resources.
		//
		ResourceSet resourceSet = new ResourceSetImpl();

		// Register the appropriate resource factory to handle all file extensions.
		//
		resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put
			(Resource.Factory.Registry.DEFAULT_EXTENSION,
			 new XMIResourceFactoryImpl());

		// Register the package to ensure it is available during loading.
		//
		resourceSet.getPackageRegistry().put
			(ShootingmachineemfmodelPackage.eNS_URI,
			 ShootingmachineemfmodelPackage.eINSTANCE);

		File file = new File("C:\\Users\\Philipp\\Documents\\YASA\\Modell\\runtime-EclipseApplication\\RemoteSystemsTempFiles\\My.shootingmachineemfmodel");
        URI uri = file.isFile() ? URI.createFileURI(file.getAbsolutePath()): URI.createURI("My.shootingmachineemfmodel");


        try {
            // Demand load resource for this file.
            //
        	Resource resource = resourceSet.getResource(uri, true);

        	ToplevelSystem mySystem = (ToplevelSystem)resource.getContents().get(0);


            //For Schleife in welcher die einzelnen Dateien und Ordner erstellt werden
            for(int i = 0; i<mySystem.getHasBrick().size(); i++)
            {

            	String Brickname = mySystem.getHasBrick().get(i).getName();
            	//Ordnername = Name des Bricks
            	File BrickFolder = new File(Brickname);

            	//Ordner erstellen, falls noch nicht vorhanden
            	if(!BrickFolder.exists()){
            		BrickFolder.mkdir();
            		System.out.print("Ordner " + Brickname + " erstellt\n");
            	}
            	else //Wenn Ordner schon vorhanden ist, Ordner mit Dateien vorher loeschen
            	{
            		for (File c : BrickFolder.listFiles())
            			c.delete();
            		BrickFolder.delete();
            		BrickFolder.mkdir();
            		System.out.print("Ordner " + Brickname + " rekursiv geloescht und neu erstellt\n");
            	}

            	/*
            	 * Ab hier werden die oil-Dateien erstellt
            	 */

            	//Dateipfad + Dateiname
            	File OilFile = new File(Brickname + "\\" + Brickname + ".oil");

            	//Datei erstellen, wenn noch nicht vorhanden
            	if (!OilFile.exists()) {
    				OilFile.createNewFile();
    				System.out.print("\tDatei " + Brickname + ".oil erstellt\n");
    			}

            	//BufferedWriter
            	FileWriter oilFileWriter = new FileWriter(OilFile.getAbsoluteFile());
            	BufferedWriter oilFileBuffer = new BufferedWriter(oilFileWriter);

            	//Anfang hardcoded
            	String oilFileBeginn = "#include \"implementation.oil\"\n\n"
            			+ "CPU ATMEL_AT91SAM7S256\n"
                		+ "{\n"
                		+ "\tOS LEJOS_OSEK\n"
                		+ "\t{\n"
                		+ "\t\tSTATUS = EXTENDED;\n"
                		+ "\t\tSTARTUPHOOK = FALSE;\n"
                		+ "\t\tERRORHOOK = FALSE;\n"
                		+ "\t\tSHUTDOWNHOOK = FALSE;\n"
                		+ "\t\tPRETASKHOOK = FALSE;\n"
                		+ "\t\tPOSTTASKHOOK = FALSE;\n"
                		+ "\t\tUSEGETSERVICEID = FALSE;\n"
                		+ "\t\tUSEPARAMETERACCESS = FALSE;\n"
                		+ "\t\tUSERESSCHEDULER = FALSE;\n"
            			+ "\t};\n\n"
                		+ "\tAPPMODE LEGOSAR{};\n\n";

            	oilFileBuffer.write(oilFileBeginn); //String Beginn(Anfang) in Datei schreiben

            	//for schleife fuer Task sektion
            	for(int j = 0; j < mySystem.getHasBrick().get(i).getHasTaskBrick().size(); j++)
            	{
            		String oilFileTask = "\tTASK " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getName() + "\n"
            				+ "\t{\n";
            		//Wenn AUTOSTART true ist:
            		if (mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).isAUTOSTART() == true)
            		{
            			oilFileTask = oilFileTask + "\t\tAUTOSTART = TRUE\n"
        						+ "\t\t{\n"
        						+ "\t\t\tAPPMODE = LEGOSAR;\n"
        						+ "\t\t};\n";
            		}
            		//AUTOSTART false
            		else
            		{
            			oilFileTask = oilFileTask + "\t\tAUTOSTART = FALSE;\n";
            		}
            		oilFileTask = oilFileTask + "\t\tPRIORITY = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getPRIORITY() + ";\n"
            				+ "\t\tACIVATION = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getACTIVATION() + ";\n"
            				+ "\t\tSCHEDULE = FULL;\n"
            				+ "\t\tSTACKSIZE = 512;\n";

            		System.out.print("\t\tTASK " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getName() + " in Datei " + Brickname +".oil hinzugefuegt\n");

            		//EVENTS die zu den TASKS gehoeren
            		for(int k = 0; k < mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasEvent().size(); k++)
            		{
            			oilFileTask = oilFileTask + "\t\tEVENT = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasEvent().get(k).getName() + ";\n";
            		}
            		oilFileTask = oilFileTask + "\t};\n\n";

            		oilFileBuffer.write(oilFileTask);

            		//for Schleife für ALARME
            		for(int k = 0; k < mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().size(); k++)
                	{
                		String oilFileAlarm = "\tALARM " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getName() + "\n"
                				+ "\t{\n"
                				+ "\t\tCOUNTER = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getName() + ";\n"
                				+ "\t\tACTION = ACTIVATETASK\n"
                				+ "\t\t{\n"
                				+ "\t\t\tTASK = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getName() + ";\n"
                				+ "\t\t};\n";
                		//AUTOSTART ist true
                		if(mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).isAUTOSTART() == true)
                		{
                			oilFileAlarm = oilFileAlarm + "\t\tAUTOSTART = TRUE\n"
                					+ "\t\t{\n"
                					+ "\t\t\tALARMTIME = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getALARMTIME() + ";\n"
                					+ "\t\t\tCYCLETIME = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getCYCLETIME() + ";\n"
                					+ "\t\t\tAPPMODE = LEGOSAR;\n"
                					+ "\t\t};\n";
                		}
                		//AUTOSTART ist false
                		else
                		{
                			oilFileAlarm = oilFileAlarm + "\t\tAUTOSTART = FALSE;\n";
                		}
                		oilFileAlarm = oilFileAlarm + "\t};\n\n";

                		//pro ALARM 1 Counter erstellen
                		String oilFileCounter = "\tCOUNTER C_" + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getName() + "\n"
                				+ "\t{\n"
                				+ "\t\tMINCYCLE = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getMINCYCLE() + ";\n"
                				+ "\t\tMAXALLOWEDVALUE = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getMAXALLOWEDVALUE() + ";\n"
                				+ "\t\tTICKSPERBASE = " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getTICKSPERBASE() + ";\n"
                				+ "\t};\n\n";

                		oilFileBuffer.write(oilFileAlarm);
                		oilFileBuffer.write(oilFileCounter);

                		System.out.print("\t\tALARM " + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getName() + " und COUNTER C_" + mySystem.getHasBrick().get(i).getHasTaskBrick().get(j).getHasAlarm().get(k).getName() + " in Datei " + Brickname +".oil hinzugefuegt\n");

                	}

            	}

            	//for Schleife fuer EVENTS
            	for (int j = 0; j < mySystem.getHasBrick().get(i).getHasEventBrick().size(); j++)
            	{
            		String oilFileEvent = "\tEVENT " + mySystem.getHasBrick().get(i).getHasEventBrick().get(j).getName() + "\n"
            				+ "\t{\n"
            				+ "\t\tMASK = AUTO;\n"
            				+ "\t};\n\n";
            		oilFileWriter.write(oilFileEvent);

            		System.out.print("\t\tEVENT " + mySystem.getHasBrick().get(i).getHasEventBrick().get(j).getName() + " in Datei " + Brickname +".oil hinzugefuegt\n");

            	}
            	oilFileBuffer.write("};");


            	oilFileBuffer.close(); //Datei schließen


            	/*
            	 * Ab hier werden die C-Dateien erstellt
            	 */

            	//Dateipfad + Dateiname
            	File cFile = new File(Brickname + "\\" + Brickname + ".c");

            	//Datei erstellen, wenn noch nicht vorhanden
            	if (!cFile.exists()) {
    				cFile.createNewFile();
    				System.out.print("\tDatei " + Brickname + ".c erstellt\n");
    			}

            	//BufferedWriter
            	FileWriter cFileWriter = new FileWriter(cFile.getAbsoluteFile());
            	BufferedWriter cFileBuffer = new BufferedWriter(cFileWriter);

            	String cFileBeginn = "#include \"kernel.h\"\n"
            			+ "#include \"kernel_id.h\"\n"
            			+ "#include \"ecrobot_interface.h\"\n\n";
            	cFileBuffer.write(cFileBeginn);

            	cFileBuffer.close();
            }


        }
        catch (RuntimeException exception) {
            System.out.println("Problem loading " + uri);
            exception.printStackTrace();
        }
        catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * Prints diagnostics with indentation.
	 * <!-- end-user-doc -->
	 * @param diagnostic the diagnostic to print.
	 * @param indent the indentation for printing.
	 * @generated
	 */
	protected static void printDiagnostic(Diagnostic diagnostic, String indent) {
		System.out.print(indent);
		System.out.println(diagnostic.getMessage());
		for (Diagnostic child : diagnostic.getChildren()) {
			printDiagnostic(child, indent + "  ");
		}
	}

} //ShootingmachineemfmodelExample
